// deposit-service/src/secure_storage.rs
use common::PulserError;
use std::fs::{self, File, OpenOptions};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use log::{info, warn, error};
use bitcoin::Network;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

// Sensitive wallet information
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WalletSecrets {
    pub user_id: u32,
    pub seed_phrase: Option<String>,      // BIP39 seed phrase (if generated by this service)
    pub descriptor: String,               // Wallet descriptor
    pub xpriv: Option<String>,            // Extended private key (if applicable)
    pub role: String,                     // user, lsp, or trustee
    pub pubkey: String,                   // Public key
    pub multisig_participants: Vec<String>, // Pubkeys of all participants
    pub network: String,                  // bitcoin, testnet, etc.
    pub created_at: i64,                  // Unix timestamp
    pub last_accessed: i64,               // Unix timestamp of last access
    pub exported_to_user: bool,           // Whether the user has received their info
}

// Store for keeping wallet secrets
pub struct SecureStorage {
    data_dir: PathBuf,
    wallets: Arc<RwLock<HashMap<u32, WalletSecrets>>>,
}

impl SecureStorage {
    pub fn new(data_dir: &str) -> Result<Self, PulserError> {
        // Create base directory
        let secrets_dir = Path::new(data_dir).join("secrets");
        if !secrets_dir.exists() {
            fs::create_dir_all(&secrets_dir)
                .map_err(|e| PulserError::StorageError(format!("Failed to create secrets directory: {}", e)))?;
            
            // Set secure permissions on Unix
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let perms = fs::Permissions::from_mode(0o700); // rwx for owner only
                fs::set_permissions(&secrets_dir, perms)
                    .map_err(|e| PulserError::StorageError(format!("Failed to set permissions: {}", e)))?;
            }
        }
        
        // Load existing wallets
        let mut wallets = HashMap::new();
        for entry in fs::read_dir(&secrets_dir).map_err(|e| PulserError::StorageError(format!("Failed to read secrets directory: {}", e)))? {
            if let Ok(entry) = entry {
                let path = entry.path();
                if path.is_file() && path.extension().map_or(false, |ext| ext == "json") {
                    if let Ok(file_content) = fs::read_to_string(&path) {
                        if let Ok(wallet_secret) = serde_json::from_str::<WalletSecrets>(&file_content) {
                            wallets.insert(wallet_secret.user_id, wallet_secret);
                        }
                    }
                }
            }
        }
        
        info!("Loaded {} wallet secrets from {}", wallets.len(), secrets_dir.display());
        
        Ok(Self {
            data_dir: PathBuf::from(data_dir),
            wallets: Arc::new(RwLock::new(wallets)),
        })
    }
    
    // Store a new wallet secret
    pub fn store_wallet(&self, wallet_secret: WalletSecrets) -> Result<(), PulserError> {
        // Serialize the data
        let json = serde_json::to_string_pretty(&wallet_secret)
            .map_err(|e| PulserError::StorageError(format!("Failed to serialize wallet secret: {}", e)))?;
        
        // Create the file path
        let secrets_dir = self.data_dir.join("secrets");
        let wallet_path = secrets_dir.join(format!("wallet_{}.json", wallet_secret.user_id));
        
        // Write to file with secure permissions
        let mut file = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(&wallet_path)
            .map_err(|e| PulserError::StorageError(format!("Failed to open wallet secret file: {}", e)))?;
            
        file.write_all(json.as_bytes())
            .map_err(|e| PulserError::StorageError(format!("Failed to write wallet secret: {}", e)))?;
            
        // Set secure permissions on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let perms = fs::Permissions::from_mode(0o600); // rw for owner only
            fs::set_permissions(&wallet_path, perms)
                .map_err(|e| PulserError::StorageError(format!("Failed to set permissions: {}", e)))?;
        }
        
        // Update in-memory cache
        let mut wallets = self.wallets.write()
            .map_err(|_| PulserError::StorageError("Failed to lock wallets for writing".to_string()))?;
        
        wallets.insert(wallet_secret.user_id, wallet_secret.clone());
        
        info!("Stored wallet secret for user {}", wallet_secret.user_id);
        
        Ok(())
    }
    
    // Get a wallet secret by user ID
    pub fn get_wallet(&self, user_id: u32) -> Result<WalletSecrets, PulserError> {
        // Try from in-memory cache first
        let wallets = self.wallets.read()
            .map_err(|_| PulserError::StorageError("Failed to lock wallets for reading".to_string()))?;
        
        if let Some(wallet) = wallets.get(&user_id) {
            return Ok(wallet.clone());
        }
        
        // If not in cache, try from file
        let secrets_dir = self.data_dir.join("secrets");
        let wallet_path = secrets_dir.join(format!("wallet_{}.json", user_id));
        
        if !wallet_path.exists() {
            return Err(PulserError::UserNotFound(format!("Wallet secret not found for user {}", user_id)));
        }
        
        let file_content = fs::read_to_string(&wallet_path)
            .map_err(|e| PulserError::StorageError(format!("Failed to read wallet secret: {}", e)))?;
            
        let wallet_secret = serde_json::from_str::<WalletSecrets>(&file_content)
            .map_err(|e| PulserError::StorageError(format!("Failed to parse wallet secret: {}", e)))?;
            
        // Update the cache
        let mut wallets = self.wallets.write()
            .map_err(|_| PulserError::StorageError("Failed to lock wallets for writing".to_string()))?;
        
        wallets.insert(user_id, wallet_secret.clone());
        
        Ok(wallet_secret)
    }
    
    // Update the last accessed time
    pub fn update_last_accessed(&self, user_id: u32) -> Result<(), PulserError> {
        let wallet_secret = self.get_wallet(user_id)?;
        let mut updated = wallet_secret.clone();
        updated.last_accessed = common::utils::now_timestamp();
        
        self.store_wallet(updated)
    }
    
    // Mark as exported to user
    pub fn mark_exported_to_user(&self, user_id: u32) -> Result<(), PulserError> {
        let wallet_secret = self.get_wallet(user_id)?;
        let mut updated = wallet_secret.clone();
        updated.exported_to_user = true;
        
        self.store_wallet(updated)
    }
    
    // Generate a user-friendly export format for cloud storage
    pub fn generate_export(&self, user_id: u32) -> Result<String, PulserError> {
        let wallet_secret = self.get_wallet(user_id)?;
        
        // Create a user-friendly format
        let export = match wallet_secret.role.as_str() {
            "user" => {
                format!(
                    "PULSER WALLET BACKUP - KEEP SECURE\n\n\
                    User ID: {}\n\
                    Network: {}\n\
                    Created: {}\n\n\
                    Your Seed Phrase (DO NOT SHARE):\n{}\n\n\
                    Your Public Key:\n{}\n\n\
                    Multisig Participants:\n{}\n\n\
                    Wallet Descriptor:\n{}\n",
                    wallet_secret.user_id,
                    wallet_secret.network,
                    common::utils::format_timestamp(wallet_secret.created_at),
                    wallet_secret.seed_phrase.unwrap_or_else(|| "Not available".to_string()),
                    wallet_secret.pubkey,
                    wallet_secret.multisig_participants.join("\n"),
                    wallet_secret.descriptor
                )
            },
            _ => {
                format!(
                    "PULSER SERVICE WALLET - {}\n\n\
                    Service ID: {}\n\
                    Network: {}\n\
                    Created: {}\n\n\
                    Public Key:\n{}\n\n\
                    Wallet Descriptor:\n{}\n",
                    wallet_secret.role.to_uppercase(),
                    wallet_secret.user_id,
                    wallet_secret.network,
                    common::utils::format_timestamp(wallet_secret.created_at),
                    wallet_secret.pubkey,
                    wallet_secret.descriptor
                )
            }
        };
        
        // Mark as exported
        self.mark_exported_to_user(user_id)?;
        
        Ok(export)
    }
    
    // Get all wallet secrets (useful for admin functions)
    pub fn list_all_wallets(&self) -> Result<Vec<WalletSecrets>, PulserError> {
        let wallets = self.wallets.read()
            .map_err(|_| PulserError::StorageError("Failed to lock wallets for reading".to_string()))?;
        
        Ok(wallets.values().cloned().collect())
    }
}
